// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package generated

import (
	"bytes"
	"context"
	"errors"
	"graphql-demo/internal/graph/model"
	"sync/atomic"

	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/introspection"
	gqlparser "github.com/vektah/gqlparser/v2"
	"github.com/vektah/gqlparser/v2/ast"
)

// NewExecutableSchema creates an ExecutableSchema from the ResolverRoot interface.
func NewExecutableSchema(cfg Config) graphql.ExecutableSchema {
	return &executableSchema{
		schema:     cfg.Schema,
		resolvers:  cfg.Resolvers,
		directives: cfg.Directives,
		complexity: cfg.Complexity,
	}
}

type Config struct {
	Schema     *ast.Schema
	Resolvers  ResolverRoot
	Directives DirectiveRoot
	Complexity ComplexityRoot
}

type ResolverRoot interface {
	Comment() CommentResolver
	Mutation() MutationResolver
	Post() PostResolver
	Query() QueryResolver
	Subscription() SubscriptionResolver
	User() UserResolver
}

type DirectiveRoot struct {
}

type ComplexityRoot struct {
	Address struct {
		City    func(childComplexity int) int
		Country func(childComplexity int) int
		Street  func(childComplexity int) int
		ZipCode func(childComplexity int) int
	}

	Comment struct {
		Content   func(childComplexity int) int
		CreatedAt func(childComplexity int) int
		ID        func(childComplexity int) int
		Post      func(childComplexity int) int
		User      func(childComplexity int) int
	}

	Mutation struct {
		CreateComment func(childComplexity int, input model.NewComment) int
		CreatePost    func(childComplexity int, input model.NewPost) int
		DeleteComment func(childComplexity int, id int) int
		DeletePost    func(childComplexity int, id int) int
	}

	Post struct {
		Body      func(childComplexity int, limit *int32, offset *int32) int
		Category  func(childComplexity int) int
		Comments  func(childComplexity int, ids []int) int
		CreatedAt func(childComplexity int) int
		ID        func(childComplexity int) int
		Ingress   func(childComplexity int) int
		Title     func(childComplexity int) int
		User      func(childComplexity int) int
	}

	Preferences struct {
		Notifications func(childComplexity int) int
		Theme         func(childComplexity int) int
	}

	Query struct {
		Comments func(childComplexity int, ids []int) int
		Posts    func(childComplexity int, ids []int) int
		Users    func(childComplexity int, ids []int) int
	}

	Subscription struct {
		CommentCreated func(childComplexity int) int
		CommentDeleted func(childComplexity int) int
		PostCreated    func(childComplexity int) int
		PostDeleted    func(childComplexity int) int
	}

	User struct {
		Address      func(childComplexity int) int
		Comments     func(childComplexity int, ids []int) int
		CreatedAt    func(childComplexity int) int
		Email        func(childComplexity int) int
		ID           func(childComplexity int) int
		LastLogin    func(childComplexity int) int
		Name         func(childComplexity int) int
		PhoneNumber  func(childComplexity int) int
		Posts        func(childComplexity int, ids []int) int
		Preferences  func(childComplexity int) int
		ProvokeError func(childComplexity int) int
		Role         func(childComplexity int) int
	}
}

type executableSchema struct {
	schema     *ast.Schema
	resolvers  ResolverRoot
	directives DirectiveRoot
	complexity ComplexityRoot
}

func (e *executableSchema) Schema() *ast.Schema {
	if e.schema != nil {
		return e.schema
	}
	return parsedSchema
}

func (e *executableSchema) Complexity(ctx context.Context, typeName, field string, childComplexity int, rawArgs map[string]any) (int, bool) {
	ec := executionContext{nil, e, 0, 0, nil}
	_ = ec
	switch typeName + "." + field {

	case "Address.city":
		if e.complexity.Address.City == nil {
			break
		}

		return e.complexity.Address.City(childComplexity), true

	case "Address.country":
		if e.complexity.Address.Country == nil {
			break
		}

		return e.complexity.Address.Country(childComplexity), true

	case "Address.street":
		if e.complexity.Address.Street == nil {
			break
		}

		return e.complexity.Address.Street(childComplexity), true

	case "Address.zipCode":
		if e.complexity.Address.ZipCode == nil {
			break
		}

		return e.complexity.Address.ZipCode(childComplexity), true

	case "Comment.content":
		if e.complexity.Comment.Content == nil {
			break
		}

		return e.complexity.Comment.Content(childComplexity), true

	case "Comment.createdAt":
		if e.complexity.Comment.CreatedAt == nil {
			break
		}

		return e.complexity.Comment.CreatedAt(childComplexity), true

	case "Comment.id":
		if e.complexity.Comment.ID == nil {
			break
		}

		return e.complexity.Comment.ID(childComplexity), true

	case "Comment.post":
		if e.complexity.Comment.Post == nil {
			break
		}

		return e.complexity.Comment.Post(childComplexity), true

	case "Comment.user":
		if e.complexity.Comment.User == nil {
			break
		}

		return e.complexity.Comment.User(childComplexity), true

	case "Mutation.createComment":
		if e.complexity.Mutation.CreateComment == nil {
			break
		}

		args, err := ec.field_Mutation_createComment_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreateComment(childComplexity, args["input"].(model.NewComment)), true

	case "Mutation.createPost":
		if e.complexity.Mutation.CreatePost == nil {
			break
		}

		args, err := ec.field_Mutation_createPost_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreatePost(childComplexity, args["input"].(model.NewPost)), true

	case "Mutation.deleteComment":
		if e.complexity.Mutation.DeleteComment == nil {
			break
		}

		args, err := ec.field_Mutation_deleteComment_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeleteComment(childComplexity, args["id"].(int)), true

	case "Mutation.deletePost":
		if e.complexity.Mutation.DeletePost == nil {
			break
		}

		args, err := ec.field_Mutation_deletePost_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.DeletePost(childComplexity, args["id"].(int)), true

	case "Post.body":
		if e.complexity.Post.Body == nil {
			break
		}

		args, err := ec.field_Post_body_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Post.Body(childComplexity, args["limit"].(*int32), args["offset"].(*int32)), true

	case "Post.category":
		if e.complexity.Post.Category == nil {
			break
		}

		return e.complexity.Post.Category(childComplexity), true

	case "Post.comments":
		if e.complexity.Post.Comments == nil {
			break
		}

		args, err := ec.field_Post_comments_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Post.Comments(childComplexity, args["ids"].([]int)), true

	case "Post.createdAt":
		if e.complexity.Post.CreatedAt == nil {
			break
		}

		return e.complexity.Post.CreatedAt(childComplexity), true

	case "Post.id":
		if e.complexity.Post.ID == nil {
			break
		}

		return e.complexity.Post.ID(childComplexity), true

	case "Post.ingress":
		if e.complexity.Post.Ingress == nil {
			break
		}

		return e.complexity.Post.Ingress(childComplexity), true

	case "Post.title":
		if e.complexity.Post.Title == nil {
			break
		}

		return e.complexity.Post.Title(childComplexity), true

	case "Post.user":
		if e.complexity.Post.User == nil {
			break
		}

		return e.complexity.Post.User(childComplexity), true

	case "Preferences.notifications":
		if e.complexity.Preferences.Notifications == nil {
			break
		}

		return e.complexity.Preferences.Notifications(childComplexity), true

	case "Preferences.theme":
		if e.complexity.Preferences.Theme == nil {
			break
		}

		return e.complexity.Preferences.Theme(childComplexity), true

	case "Query.comments":
		if e.complexity.Query.Comments == nil {
			break
		}

		args, err := ec.field_Query_comments_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Comments(childComplexity, args["ids"].([]int)), true

	case "Query.posts":
		if e.complexity.Query.Posts == nil {
			break
		}

		args, err := ec.field_Query_posts_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Posts(childComplexity, args["ids"].([]int)), true

	case "Query.users":
		if e.complexity.Query.Users == nil {
			break
		}

		args, err := ec.field_Query_users_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Users(childComplexity, args["ids"].([]int)), true

	case "Subscription.commentCreated":
		if e.complexity.Subscription.CommentCreated == nil {
			break
		}

		return e.complexity.Subscription.CommentCreated(childComplexity), true

	case "Subscription.commentDeleted":
		if e.complexity.Subscription.CommentDeleted == nil {
			break
		}

		return e.complexity.Subscription.CommentDeleted(childComplexity), true

	case "Subscription.postCreated":
		if e.complexity.Subscription.PostCreated == nil {
			break
		}

		return e.complexity.Subscription.PostCreated(childComplexity), true

	case "Subscription.postDeleted":
		if e.complexity.Subscription.PostDeleted == nil {
			break
		}

		return e.complexity.Subscription.PostDeleted(childComplexity), true

	case "User.address":
		if e.complexity.User.Address == nil {
			break
		}

		return e.complexity.User.Address(childComplexity), true

	case "User.comments":
		if e.complexity.User.Comments == nil {
			break
		}

		args, err := ec.field_User_comments_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.User.Comments(childComplexity, args["ids"].([]int)), true

	case "User.createdAt":
		if e.complexity.User.CreatedAt == nil {
			break
		}

		return e.complexity.User.CreatedAt(childComplexity), true

	case "User.email":
		if e.complexity.User.Email == nil {
			break
		}

		return e.complexity.User.Email(childComplexity), true

	case "User.id":
		if e.complexity.User.ID == nil {
			break
		}

		return e.complexity.User.ID(childComplexity), true

	case "User.lastLogin":
		if e.complexity.User.LastLogin == nil {
			break
		}

		return e.complexity.User.LastLogin(childComplexity), true

	case "User.name":
		if e.complexity.User.Name == nil {
			break
		}

		return e.complexity.User.Name(childComplexity), true

	case "User.phoneNumber":
		if e.complexity.User.PhoneNumber == nil {
			break
		}

		return e.complexity.User.PhoneNumber(childComplexity), true

	case "User.posts":
		if e.complexity.User.Posts == nil {
			break
		}

		args, err := ec.field_User_posts_args(ctx, rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.User.Posts(childComplexity, args["ids"].([]int)), true

	case "User.preferences":
		if e.complexity.User.Preferences == nil {
			break
		}

		return e.complexity.User.Preferences(childComplexity), true

	case "User.provokeError":
		if e.complexity.User.ProvokeError == nil {
			break
		}

		return e.complexity.User.ProvokeError(childComplexity), true

	case "User.role":
		if e.complexity.User.Role == nil {
			break
		}

		return e.complexity.User.Role(childComplexity), true

	}
	return 0, false
}

func (e *executableSchema) Exec(ctx context.Context) graphql.ResponseHandler {
	opCtx := graphql.GetOperationContext(ctx)
	ec := executionContext{opCtx, e, 0, 0, make(chan graphql.DeferredResult)}
	inputUnmarshalMap := graphql.BuildUnmarshalerMap(
		ec.unmarshalInputNewComment,
		ec.unmarshalInputNewPost,
	)
	first := true

	switch opCtx.Operation.Operation {
	case ast.Query:
		return func(ctx context.Context) *graphql.Response {
			var response graphql.Response
			var data graphql.Marshaler
			if first {
				first = false
				ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
				data = ec._Query(ctx, opCtx.Operation.SelectionSet)
			} else {
				if atomic.LoadInt32(&ec.pendingDeferred) > 0 {
					result := <-ec.deferredResults
					atomic.AddInt32(&ec.pendingDeferred, -1)
					data = result.Result
					response.Path = result.Path
					response.Label = result.Label
					response.Errors = result.Errors
				} else {
					return nil
				}
			}
			var buf bytes.Buffer
			data.MarshalGQL(&buf)
			response.Data = buf.Bytes()
			if atomic.LoadInt32(&ec.deferred) > 0 {
				hasNext := atomic.LoadInt32(&ec.pendingDeferred) > 0
				response.HasNext = &hasNext
			}

			return &response
		}
	case ast.Mutation:
		return func(ctx context.Context) *graphql.Response {
			if !first {
				return nil
			}
			first = false
			ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
			data := ec._Mutation(ctx, opCtx.Operation.SelectionSet)
			var buf bytes.Buffer
			data.MarshalGQL(&buf)

			return &graphql.Response{
				Data: buf.Bytes(),
			}
		}
	case ast.Subscription:
		next := ec._Subscription(ctx, opCtx.Operation.SelectionSet)

		var buf bytes.Buffer
		return func(ctx context.Context) *graphql.Response {
			buf.Reset()
			data := next(ctx)

			if data == nil {
				return nil
			}
			data.MarshalGQL(&buf)

			return &graphql.Response{
				Data: buf.Bytes(),
			}
		}

	default:
		return graphql.OneShot(graphql.ErrorResponse(ctx, "unsupported GraphQL operation"))
	}
}

type executionContext struct {
	*graphql.OperationContext
	*executableSchema
	deferred        int32
	pendingDeferred int32
	deferredResults chan graphql.DeferredResult
}

func (ec *executionContext) processDeferredGroup(dg graphql.DeferredGroup) {
	atomic.AddInt32(&ec.pendingDeferred, 1)
	go func() {
		ctx := graphql.WithFreshResponseContext(dg.Context)
		dg.FieldSet.Dispatch(ctx)
		ds := graphql.DeferredResult{
			Path:   dg.Path,
			Label:  dg.Label,
			Result: dg.FieldSet,
			Errors: graphql.GetErrors(ctx),
		}
		// null fields should bubble up
		if dg.FieldSet.Invalids > 0 {
			ds.Result = graphql.Null
		}
		ec.deferredResults <- ds
	}()
}

func (ec *executionContext) introspectSchema() (*introspection.Schema, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapSchema(ec.Schema()), nil
}

func (ec *executionContext) introspectType(name string) (*introspection.Type, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapTypeFromDef(ec.Schema(), ec.Schema().Types[name]), nil
}

var sources = []*ast.Source{
	{Name: "../schema/comment.graphqls", Input: `extend type Query {
  "Retrieve comments by their IDs. If no IDs provided, returns all comments."
  comments(
    "Array of comment IDs to retrieve. If null or empty, returns all comments."
    ids: [ID!]
  ): [Comment!]!
}

extend type Mutation {
  "Create a new comment on a post."
  createComment(
    "Input data for creating the comment."
    input: NewComment!
  ): Comment!
  "Delete a comment by its ID."
  deleteComment("ID of the comment to delete." id: ID!): Boolean!
}

extend type Subscription {
  "Subscribe to new comment creation events."
  commentCreated: Comment!
  "Subscribe to comment deletion events."
  commentDeleted: ID!
}

"A comment made by a user on a post."
type Comment {
  "Unique identifier for the comment."
  id: ID!
  "The post this comment belongs to."
  post: Post!
  "The user who made this comment."
  user: User!
  "Timestamp when the comment was created."
  createdAt: Time!
  "The text content of the comment."
  content: String!
}

"Input for creating a new comment."
input NewComment {
  "Optional ID for the comment. If not provided, one will be generated."
  id: ID
  "ID of the post to comment on."
  postId: ID!
  "ID of the user making the comment."
  userId: ID!
  "The text content of the comment."
  content: String!
}
`, BuiltIn: false},
	{Name: "../schema/post.graphqls", Input: `extend type Query {
  "Retrieve posts by their IDs. If no IDs provided, returns all posts."
  posts(
    "Array of post IDs to retrieve. If null or empty, returns all posts."
    ids: [ID!]
  ): [Post!]!
}

extend type Mutation {
  "Create a new post."
  createPost("Input data for creating the post." input: NewPost!): Post!
  "Delete a post by its ID."
  deletePost("ID of the post to delete." id: ID!): Boolean!
}

extend type Subscription {
  "Subscribe to new post creation events."
  postCreated: Post!
  "Subscribe to post deletion events."
  postDeleted: ID!
}

"A blog post or article created by a user."
type Post {
  "Unique identifier for the post."
  id: ID!
  "Title of the post."
  title: String!
  "Brief introduction or summary of the post."
  ingress: String!
  "Main content of the post. Can be limited and offset for pagination."
  body(
    "Maximum number of characters to return. If null, returns the full body."
    limit: Int
    "Number of characters to skip from the beginning."
    offset: Int
  ): String!
  "The user who created this post."
  user: User!
  "Category classification of the post."
  category: Category!
  "Timestamp when the post was created."
  createdAt: Time!
  "Comments on this post. Can be filtered by comment IDs."
  comments(
    "Array of comment IDs to filter by. If null or empty, returns all comments on this post."
    ids: [ID!]
  ): [Comment!]!
}

"Categories for organizing posts."
enum Category {
  "Technology-related posts."
  Technology
  "Science-related posts."
  Science
  "Business-related posts."
  Business
  "Entertainment-related posts."
  Entertainment
  "Health-related posts."
  Health
}

"Input for creating a new post."
input NewPost {
  "Optional ID for the post. If not provided, one will be generated."
  id: ID
  "ID of the user creating the post."
  userId: ID!
  "Title of the post."
  title: String!
  "Brief introduction or summary of the post."
  ingress: String!
  "Main content of the post."
  body: String!
  "Category classification of the post."
  category: Category!
}
`, BuiltIn: false},
	{Name: "../schema/schema.graphqls", Input: `"Custom scalar representing a timestamp in RFC3339 format."
scalar Time
`, BuiltIn: false},
	{Name: "../schema/user.graphqls", Input: `extend type Query {
  "Retrieve users by their IDs. If no IDs provided, returns all users."
  users(
    "Array of user IDs to retrieve. If null or empty, returns all users."
    ids: [ID!]
  ): [User!]!
}

"A user in the system with profile information and preferences."
type User {
  "Unique identifier for the user."
  id: ID!
  "Full name of the user."
  name: String!
  "Email address of the user."
  email: String!
  "Phone number of the user."
  phoneNumber: String!
  "Physical address of the user."
  address: Address!
  "Role assigned to the user in the system."
  role: Role!
  "Timestamp when the user account was created."
  createdAt: Time!
  "Timestamp of the user's last login."
  lastLogin: Time!
  "User's personal preferences and settings."
  preferences: Preferences!
  "Posts created by this user. Can be filtered by post IDs."
  posts(
    "Array of post IDs to filter by. If null or empty, returns all posts by this user."
    ids: [ID!]
  ): [Post!]!
  "Comments made by this user. Can be filtered by comment IDs."
  comments(
    "Array of comment IDs to filter by. If null or empty, returns all comments by this user."
    ids: [ID!]
  ): [Comment!]!
  "Field that can be used to test error handling."
  provokeError: Boolean!
}

"Physical address information for a user."
type Address {
  "Street address line."
  street: String!
  "City name."
  city: String!
  "Postal/ZIP code."
  zipCode: String!
  "Country name."
  country: String!
}

"User roles in the system."
enum Role {
  "Administrator with full system access."
  admin
  "Regular user with limited access."
  user
}

"User preferences and settings."
type Preferences {
  "UI theme preference (e.g., 'light', 'dark')."
  theme: String!
  "Whether the user wants to receive notifications."
  notifications: Boolean!
}
`, BuiltIn: false},
}
var parsedSchema = gqlparser.MustLoadSchema(sources...)
